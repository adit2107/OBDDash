{
  "_from": "azure-event-hubs",
  "_id": "azure-event-hubs@0.2.11",
  "_inBundle": false,
  "_integrity": "sha512-cLiR3v4VISZd7syjA4CR/FumLQk3N+k73AjsecL7LhNWpXcaEkGNcTxojkCd8u/ON1XsVSbh8YgFVMUtz1BxXQ==",
  "_location": "/azure-event-hubs",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "azure-event-hubs",
    "fetchSpec": "latest",
    "name": "azure-event-hubs",
    "raw": "azure-event-hubs",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/azure-event-hubs/-/azure-event-hubs-0.2.11.tgz",
  "_shasum": "cac429c9c8e2910388eb5ff942177a30c7e2a921",
  "_shrinkwrap": null,
  "_spec": "azure-event-hubs",
  "_where": "D:\\BoschStuff\\Web Dash",
  "author": {
    "name": "Microsoft Corporation"
  },
  "bugs": {
    "url": "http://github.com/Azure/azure-event-hubs-node/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "async-lock": "^1.1.3",
    "debug": "^3.1.0",
    "is-buffer": "2.0.2",
    "jssha": "^2.3.1",
    "ms-rest": "^2.3.6",
    "ms-rest-azure": "^2.5.7",
    "rhea": "^0.3.1",
    "tslib": "^1.9.3",
    "uuid": "^3.3.2"
  },
  "deprecated": "< 0.2.12",
  "description": "Azure Event Hubs SDK for Node.js",
  "devDependencies": {
    "@types/async-lock": "^1.1.0",
    "@types/chai": "^4.1.4",
    "@types/chai-as-promised": "^7.1.0",
    "@types/debug": "^0.0.30",
    "@types/dotenv": "^4.0.3",
    "@types/mocha": "^5.2.5",
    "@types/node": "^8.0.37",
    "@types/uuid": "^3.4.3",
    "chai": "^4.1.2",
    "chai-as-promised": "^7.1.1",
    "dotenv": "^6.0.0",
    "mocha": "^5.2.0",
    "nyc": "^12.0.2",
    "ts-node": "^5.0.1",
    "tslint": "^5.11.0",
    "typescript": "^3.0.1"
  },
  "homepage": "https://github.com/Azure/azure-event-hubs-node/tree/master/client",
  "license": "MIT",
  "main": "./dist/lib/index.js",
  "name": "azure-event-hubs",
  "optionalDependencies": {},
  "readme": "### azure-event-hubs\n\n\nDeprecation warning\n================\n**This package has been deprecated. Please use [@azure/event-hubs](https://www.npmjs.com/package/@azure/event-hubs) instead.**\n\nPlease install:\n\n```\nnpm i @azure/event-hubs\n```\n\nAzure Event Hubs is a scalable event processing service that ingests and processes large volumes of events and data, with low latency and high reliability. More information about Azure Event Hubs can be found over [here](https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-features).\n\nThis sdk provides a convenient way to interact with the Azure Event Hubs service.\n\n## Pre-requisite ##\n- **Node.js version: 8.x or higher.** We would encourage you to install the latest available LTS version at any given time from https://nodejs.org. **Please do not use older LTS versions of node.js.**\n\n## Installation ##\n```bash\nnpm install azure-event-hubs\n```\n\n### Client creation\nThe simplest usage is to use the static factory method `EventHubClient.createFromConnectionString(_connection-string_, _event-hub-path_)`. Once you have a client, you can use it for:\n\n### Sending events\n- You can send a single event using `client.send()` method.\n- You can even batch multiple events together using `client.sendBatch()` method.\n\n### Receiving events\nThere are two ways to receive events using the EventHub Client.\n\n#### Streaming receiver\nThe `EventHubClient` has a `client.receive(. . .)` method on the receiver.\nThis message takes the `messageHandler()` and the `errorHandler()` amongst other parameters and registers them to the receiver. \nThis method returns a `ReceiverHandler` that can be used to stop receiving further events `await receiverHandler.stop()`\nThis mechanism can be useful in a scenario, where you want to continuously receive events/messages at a high speed.\n\n#### Batching receiver\nYou can use `await client.receiveBatch(...)` to receive desired number of events for specified amount of time.\nIt will return an array of EventData objects once it receives the desired number of events or the max wait time occurs (which ever happens first). This mechanism can be useful when you want to receive events/messages in a batch. If your in a scenario where you\nwould like to receive some messages and process them (since message processing is time consuming), and later get some more messages,\nthen this mechanism will suite your needs better.\n\n**Note:** For scalable and efficient receiving, please take a look at [azure-event-processor-host](https://github.com/Azure/azure-event-hubs-node/tree/master/processor). The Event Processor host, internally uses the streaming receiver\nto receive messages.\n\n## IDE ##\nThis sdk has been developed in [TypeScript](https://typescriptlang.org) and has good source code documentation. It is highly recommended to use [vscode](https://code.visualstudio.com) \nor any other IDE that provides better intellisense and exposes the full power of source code documentation.\n\n## Debug logs ##\n\nYou can set the following environment variable to get the debug logs.\n\n- Getting debug logs from the Event Hub SDK\n```bash\nexport DEBUG=azure*\n```\n- Getting debug logs from the Event Hub SDK and the protocol level library.\n```bash\nexport DEBUG=azure*,rhea*\n```\n- If you are **not interested in viewing the message transformation** (which consumes lot of console/disk space) then you can set the `DEBUG` environment variable as follows:\n```bash\nexport DEBUG=azure*,rhea*,-rhea:raw,-rhea:message,-azure:amqp-common:datatransformer\n```\n- If you are interested only in **errors**, then you can set the `DEBUG` environment variable as follows:\n```bash\nexport DEBUG=azure:event-hubs:error,azure-amqp-common:error,rhea-promise:error,rhea:events,rhea:frames,rhea:io,rhea:flow\n```\n\n#### Logging to a file\n- Set the `DEBUG` environment variable as shown above and then run your test script as follows:\n  - Logging statements from you test script go to `out.log` and logging statement from the sdk go to `debug.log`.\n    ```bash\n    node your-test-script.js > out.log 2>debug.log\n    ```\n  - Logging statements from your test script and the sdk go to the same file `out.log` by redirecting stderr to stdout (&1), and then redirect stdout to a file:\n    ```bash\n    node your-test-script.js >out.log 2>&1\n    ```\n  - Logging statements from your test script and the sdk go to the same file `out.log`.\n    ```bash\n      node your-test-script.js &> out.log\n    ```\n\n## Examples ##\n\nPlease take a look at the [examples](https://github.com/Azure/azure-event-hubs-node/tree/master/client/examples) directory for detailed examples.\n\n## Example 1 - Get the partition IDs.\n\n```js\nconst { EventHubClient } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  const partitionIds = await client.getPartitionIds();\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 2.1 - Receive events with handlers\nThis mechanism is useful for receiving events for a longer duration.\n\nReceive events from partition ID 1 after the current time.\n```js\nconst { EventHubClient, EventPosition } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  const onError = (err) => {\n    console.log(\"An error occurred on the receiver \", err);\n  };\n  \n  const onMessage = (eventData) => {\n    console.log(eventData.body);\n    const enqueuedTime = eventData.annotations[\"x-opt-enqueued-time\"];\n    console.log(\"Enqueued Time: \", enqueuedTime);\n  };\n\n  const receiveHandler = client.receive(\"1\", onMessage, onError, { eventPosition: EventPosition.fromEnqueuedTime(Date.now()) });\n\n  // To stop receiving events later on...\n  await receiveHandler.stop();\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 2.2 - Receive specified number of events for a given time\nThis mechanism is useful when you want to see how the received events look like. It can also be useful for debugging purpose.\n\nReceive events from partitionId `\"1\"` after the current time.\n```js\nconst { EventHubClient, EventPosition } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  const datas = await client.receiveBatch(\"1\", 100 /*number of events*/, 20 /*amount of time in seconds the receiver should run. Default 60 seconds.*/, { eventPosition: EventPosition.fromEnqueuedTime(Date.now()) });\n  console.log(\"Array of EventData objects\", datas);\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 3 - Send an event with partition key.\n\nSend an event with a given \"partition-key\" which is then hashed to a partition ID (so all events with the same key will go to the same ID, but load is balanced between partitions). \n\n```js\nconst { EventHubClient, EventPosition } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  // NOTE: For receiving events from Azure Stream Analytics, please send Events to an EventHub where the body is a JSON object.\n  // const eventData = { body: { \"message\": \"Hello World\" }, partitionKey: \"pk12345\"};\n  const eventData = { body: \"Hello World\", partitionKey: \"pk12345\"};\n  const delivery = await client.send(eventData);\n  console.log(\"message sent successfully.\");\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 4 - Send an event to a specific partition id.\n\nSend an event to a specific partition ID if needed. If not specified then EventHub will store the events in the partition in a round-robin pattern.\n\n```js\nconst { EventHubClient, EventPosition } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  // NOTE: For receiving events from Azure Stream Analytics, please send Events to an EventHub where the body is a JSON object/array.\n  // const eventData = { body: { \"message\": \"Hello World\" } };\n  const data = { body: \"Hello World 1\", message_id: \"343-0909-5454-23423-54543\" };\n  const delivery = await client.send(data, \"1\");\n  console.log(\"message sent successfully.\");\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 5 - Send multiple events as a batch. \n\nSend multiple events grouped together.\n\n```js\nconst { EventHubClient, EventPosition } = require('azure-event-hubs');\n\nconst client = EventHubClient.createFromConnectionString(process.env[\"EVENTHUB_CONNECTION_STRING\"], process.env[\"EVENTHUB_NAME\"]);\n\nasync function main() {\n  const datas = [\n    { body: \"Hello World 1\", applicationProperties: { id: \"Some id\" }, partitionKey: \"pk786\" },\n    { body: \"Hello World 2\" },\n    { body: \"Hello World 3\" }\n  ];\n  // NOTE: For receiving events from Azure Stream Analytics, please send Events to an EventHub\n  // where the body is a JSON object/array.\n  // const datas = [\n  //   { body: { \"message\": \"Hello World 1\" }, applicationProperties: { id: \"Some id\" }, partitionKey: \"pk786\" },\n  //   { body: { \"message\": \"Hello World 2\" } },\n  //   { body: { \"message\": \"Hello World 3\" } }\n  // ];\n  const delivery = await client.sendBatch(datas);\n  console.log(\"message sent successfully.\");\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## Example 6 - Create an EventHubClient from an IotHub connection string.\n\nCreate EventHub Client from an IotHub Connection string. This is useful for receiving telemetry data\nof IotHub from the linked EventHub. Most likely the associated connection string will not have send\nclaims. Hence getting HubRuntimeInfo or PartitionRuntimeInfo and receiving messages would be the\npossible operations.\n\n- Please notice that we are awaiting on the `createFromIotHubConnectionString()` method to get an\ninstance of the `EventHubClient`. This is different from other static methods on the client. The method\ntalks to the IotHub endpoint to get a redirect error which contains the EventHub endpoint to talk to.\nIt then constructs the right EventHub connection string based on the information in the redirect error\nand returns an instance of the EventHubClient that you can play with.\n```js\nconst { EventHubClient } = require('azure-event-hubs');\n\nasync function main() {\n  const client = await EventHubClient.createFromIotHubConnectionString(process.env[\"IOTHUB_CONNECTION_STRING\"]);\n  const hubInfo = await client.getHubRuntimeInformation();\n  console.log(hubInfo);\n  await client.close();\n}\n\nmain().catch((err) => {\n  console.log(err);\n});\n```\n\n## AMQP Dependencies ##\nIt depends on [rhea](https://github.com/amqp/rhea) library for managing connections, sending and receiving events over the [AMQP](http://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-complete-v1.0-os.pdf) protocol.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/azure/azure-event-hubs-node.git"
  },
  "scripts": {
    "build": "npm run tslint && npm run tsc",
    "prepare": "npm run build",
    "test": "npm run build",
    "tsc": "tsc",
    "tslint": "tslint -p . -c tslint.json --exclude examples/**/*.ts --exclude tests/**/*.ts",
    "unit": "nyc --reporter=lcov --reporter=text-lcov mocha -r ts-node/register -t 50000 ./tests/**/*.spec.ts --abort-on-uncaught-exception"
  },
  "types": "./typings/lib/index.d.ts",
  "version": "0.2.11"
}
